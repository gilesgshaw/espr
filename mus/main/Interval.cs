using System;
using static mus.Gen.Ut;
using static mus.Notation;

namespace mus
{

    // compared by...
    public struct IntervalC : IEquatable<IntervalC>, IComparable<IntervalC>
    {
        public int Semis;
        public int Number;

        #region AutoGenerated

        public IntervalC(int number, int semis)
        {
            Number = number;
            Semis = semis;
        }

        public override bool Equals(object obj) => obj is IntervalC interval && Equals(interval);

        public bool Equals(IntervalC other) => Semis == other.Semis && Number == other.Number;

        public static bool operator ==(IntervalC left, IntervalC right) => left.Equals(right);

        public static bool operator !=(IntervalC left, IntervalC right) => !(left == right);

        public override int GetHashCode()
        {
            int hashCode = 1960790096;
            hashCode = hashCode * -1521134295 + Semis.GetHashCode();
            hashCode = hashCode * -1521134295 + Number.GetHashCode();
            return hashCode;
        }

        public static bool operator <(IntervalC left, IntervalC right) => left.CompareTo(right) < 0;

        public static bool operator <=(IntervalC left, IntervalC right) => left.CompareTo(right) <= 0;

        public static bool operator >(IntervalC left, IntervalC right) => left.CompareTo(right) > 0;

        public static bool operator >=(IntervalC left, IntervalC right) => left.CompareTo(right) >= 0;

        #endregion

        public IntervalC(int number, int quality, int octaves)
        {
            Number = number + octaves * 7;
            Semis = 0;
            Semis = quality - Quality;
        }

        public override string ToString()
        {
            return Octaves + ": " + QualityName(Quality, Degree.IsConsonant(ResidueNumber)) + " " + Degree.Interval(ResidueNumber);
        }

        public int Quality => ResidueSemis - Degree.Semis(ResidueNumber);

        public int CompareTo(IntervalC other)
        {
            int result = Number.CompareTo(other.Number);
            if (result != 0) return result;
            return Semis.CompareTo(other.Semis);
        }

        public static IntervalC operator +(IntervalC a, IntervalC b) => new IntervalC(a.Number + b.Number, a.Semis + b.Semis);

        public static IntervalC operator -(IntervalC a) => new IntervalC(-a.Number, -a.Semis);

        public static IntervalC operator -(IntervalC a, IntervalC b) => new IntervalC(a.Number - b.Number, a.Semis - b.Semis);

        public int ResidueNumber => mod(7, Number);

        public int ResidueSemis => Semis - 12 * ((Number - mod(7, Number)) / 7);

        public IntervalS Residue => new IntervalS(this);

        public int Octaves => (Number - mod(7, Number)) / 7;
    }

    //now considered subset of above, with numbers 0 to 6
    public struct IntervalS : IEquatable<IntervalS>
    {
        public int ResidueNumber; //from 0 to 6.
        public int ResidueSemis;

        #region AutoGenerated

        public bool Equals(IntervalS other) => ResidueSemis == other.ResidueSemis && ResidueNumber == other.ResidueNumber;

        public override int GetHashCode()
        {
            int hashCode = 2051449748;
            hashCode = hashCode * -1521134295 + ResidueNumber.GetHashCode();
            hashCode = hashCode * -1521134295 + ResidueSemis.GetHashCode();
            return hashCode;
        }

        public static bool operator ==(IntervalS left, IntervalS right) => left.Equals(right);

        public static bool operator !=(IntervalS left, IntervalS right) => !(left == right);

        public override bool Equals(object obj) => obj is IntervalS interval && Equals(interval);

        #endregion

        public IntervalS(IntervalC interval)
        {
            ResidueNumber = interval.ResidueNumber;
            ResidueSemis = interval.ResidueSemis;
        }

        public IntervalS(int number, int semis) : this(new IntervalC(number, semis)) { } //will automatically 'normalise'

        public override string ToString()
        {
            return QualityName(Quality, Degree.IsConsonant(ResidueNumber)) + " " + Degree.Interval(ResidueNumber);
        }

        //will accept any 'number' and calculate residue.
        public static IntervalS GetNew(int number, int quality) => new IntervalS(new IntervalC(number, quality, 0));

        public static explicit operator IntervalS(IntervalC obj) => new IntervalS(obj);

        public static implicit operator IntervalC(IntervalS obj) => new IntervalC(obj.ResidueNumber, obj.ResidueSemis);

        public int Quality => ResidueSemis - Degree.Semis(ResidueNumber);

        public static IntervalS operator +(IntervalS a, IntervalS b) => new IntervalS(a.ResidueNumber + b.ResidueNumber, a.ResidueSemis + b.ResidueSemis);

        public static IntervalS operator -(IntervalS a) => new IntervalS(-a.ResidueNumber, -a.ResidueSemis);

        public static IntervalS operator -(IntervalS a, IntervalS b) => new IntervalS(a.ResidueNumber - b.ResidueNumber, a.ResidueSemis - b.ResidueSemis);
    }

}
