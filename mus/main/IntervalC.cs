using System;
using static mus.Gen.Ut;
using static mus.Notation;

namespace mus
{

    // compared by...
    public struct IntervalC : IEquatable<IntervalC>, IComparable<IntervalC>
    {
        public int Semis;
        public int Number;

        #region AutoGenerated

        public IntervalC(int number, int semis)
        {
            Number = number;
            Semis = semis;
        }

        public override bool Equals(object obj) => obj is IntervalC interval && Equals(interval);

        public bool Equals(IntervalC other) => Semis == other.Semis && Number == other.Number;

        public static bool operator ==(IntervalC left, IntervalC right) => left.Equals(right);

        public static bool operator !=(IntervalC left, IntervalC right) => !(left == right);

        public override int GetHashCode()
        {
            int hashCode = 1960790096;
            hashCode = hashCode * -1521134295 + Semis.GetHashCode();
            hashCode = hashCode * -1521134295 + Number.GetHashCode();
            return hashCode;
        }

        public static bool operator <(IntervalC left, IntervalC right) => left.CompareTo(right) < 0;

        public static bool operator <=(IntervalC left, IntervalC right) => left.CompareTo(right) <= 0;

        public static bool operator >(IntervalC left, IntervalC right) => left.CompareTo(right) > 0;

        public static bool operator >=(IntervalC left, IntervalC right) => left.CompareTo(right) >= 0;

        #endregion

        public IntervalC(int number, int quality, int octaves)
        {
            Number = number + octaves * 7;
            Semis = 0;
            Semis = quality - Quality;
        }

        public override string ToString()
        {
            return Octaves + ": " + QualityName(Quality, Degree.IsConsonant(ResidueNumber)) + " " + Degree.Interval(ResidueNumber);
        }

        public int Quality => ResidueSemis - Degree.Semis(ResidueNumber);

        public int CompareTo(IntervalC other)
        {
            int result = Number.CompareTo(other.Number);
            if (result != 0) return result;
            return Semis.CompareTo(other.Semis);
        }

        public static IntervalC operator +(IntervalC a, IntervalC b) => new IntervalC(a.Number + b.Number, a.Semis + b.Semis);

        public static IntervalC operator -(IntervalC a) => new IntervalC(-a.Number, -a.Semis);

        public static IntervalC operator -(IntervalC a, IntervalC b) => new IntervalC(a.Number - b.Number, a.Semis - b.Semis);

        public int ResidueNumber => mod(7, Number);

        public int ResidueSemis => Semis - 12 * ((Number - mod(7, Number)) / 7);

        public IntervalS Residue => new IntervalS(this);

        public int Octaves => (Number - mod(7, Number)) / 7;
    }

}
