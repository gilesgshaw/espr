using System;

namespace mus
{

    public static partial class notation
    {

        // compared by...
        public struct IntervalC : IEquatable<IntervalC>, IComparable<IntervalC>
        {
            public int Semis;
            public int Number;

            #region AutoGenerated

            public IntervalC(int number, int semis)
            {
                Number = number;
                Semis = semis;
            }

            public override bool Equals(object obj) => obj is IntervalC interval && Equals(interval);

            public bool Equals(IntervalC other) => Semis == other.Semis && Number == other.Number;

            public static bool operator ==(IntervalC left, IntervalC right) => left.Equals(right);

            public static bool operator !=(IntervalC left, IntervalC right) => !(left == right);

            public override int GetHashCode()
            {
                int hashCode = 1960790096;
                hashCode = hashCode * -1521134295 + Semis.GetHashCode();
                hashCode = hashCode * -1521134295 + Number.GetHashCode();
                return hashCode;
            }

            public static bool operator <(IntervalC left, IntervalC right) => left.CompareTo(right) < 0;

            public static bool operator <=(IntervalC left, IntervalC right) => left.CompareTo(right) <= 0;

            public static bool operator >(IntervalC left, IntervalC right) => left.CompareTo(right) > 0;

            public static bool operator >=(IntervalC left, IntervalC right) => left.CompareTo(right) >= 0;

            #endregion

            public IntervalC(int number, int quality, int octaves)
            {
                Number = number + octaves * 7;
                Semis = 0;
                Semis = quality - Quality;
            }

            public int Quality => ResidueSemis - Degree.Semis(ResidueNumber);

            public int CompareTo(IntervalC other)
            {
                int result = Number.CompareTo(other.Number);
                if (result != 0) return result;
                return Semis.CompareTo(other.Semis);
            }

            public static IntervalC operator +(IntervalC a, IntervalC b) => new IntervalC(a.Number + b.Number, a.Semis + b.Semis);

            public static IntervalC operator -(IntervalC a) => new IntervalC(-a.Number, -a.Semis);

            public static IntervalC operator -(IntervalC a, IntervalC b) => new IntervalC(a.Number - b.Number, a.Semis - b.Semis);

            public int ResidueNumber => mod(7, Number);

            public int ResidueSemis => Semis - 12 * ((Number - mod(7, Number)) / 7);

            public IntervalS Residue => new IntervalS(this);

            public int Octaves => (Number - mod(7, Number)) / 7;
        }

        public struct IntervalS : IEquatable<IntervalS>
        {
            public int ResidueNumber; //from 0 to 6.
            public int ResidueSemis;

            #region AutoGenerated

            public bool Equals(IntervalS other) => ResidueSemis == other.ResidueSemis && ResidueNumber == other.ResidueNumber;
            
            public override int GetHashCode()
            {
                int hashCode = 2051449748;
                hashCode = hashCode * -1521134295 + ResidueNumber.GetHashCode();
                hashCode = hashCode * -1521134295 + ResidueSemis.GetHashCode();
                return hashCode;
            }

            public static bool operator ==(IntervalS left, IntervalS right) => left.Equals(right);

            public static bool operator !=(IntervalS left, IntervalS right) => !(left == right);

            public override bool Equals(object obj) => obj is IntervalS interval && Equals(interval);

            #endregion

            public IntervalS(IntervalC interval)
            {
                ResidueNumber = interval.ResidueNumber;
                ResidueSemis = interval.ResidueSemis;
            }

            public IntervalS(int number, int semis) : this(new IntervalC(number, semis)) { } //will automatically 'normalise'

            public static IntervalS GetNew(int number, int quality) => new IntervalS(new IntervalC(number, quality, 0));

            public static explicit operator IntervalS(IntervalC obj) => new IntervalS(obj);

            public int Quality => ResidueSemis - Degree.Semis(ResidueNumber);

            public static IntervalS operator +(IntervalS a, IntervalS b) => new IntervalS(a.ResidueNumber + b.ResidueNumber, a.ResidueSemis + b.ResidueSemis);

            public static IntervalS operator -(IntervalS a) => new IntervalS(-a.ResidueNumber, -a.ResidueSemis);

            public static IntervalS operator -(IntervalS a, IntervalS b) => new IntervalS(a.ResidueNumber - b.ResidueNumber, a.ResidueSemis - b.ResidueSemis);
        }

    }
}

//private static string GetOrdinalSuffix(int n)
//{
//    if (n < 0)
//        throw new ArgumentException();
//    n = n % 100;
//    if (n == 11 || n == 12 || n == 13)
//        return "th";
//    if (n % 10 == 1)
//        return "st";
//    if (n % 10 == 2)
//        return "nd";
//    if (n % 10 == 3)
//        return "rd";
//    return "th";
//}
